# Docker-概述

## 1.1. 什么是Docker

Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 

 

## 1.2. Docker与传统虚拟机的区别

传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。



## 1.3. Docker的发展史

1979年，有了容器技术的雏形，chroot技术的引进开启了进程隔离技术

2000年，FreeBSD Jails将计算机分为多个独立的小型计算系统。

2006年，谷歌 Process Containers技术，在进程隔离的基础上，进行了计算资源的限制

2018年，LXC，作为第一个完整的容器管理工具

2013年，LMCTFY实现了linux应用程序的程序化，成为libcontainer的重要组成部分。

2013年，Docker最初使用的是LXC，后来被替换成libcontainer

 

 

## 1.4. Docker的核心技术

Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。

主要内核技术介绍

### 1.4.1. CGOUP

其名称源自控制组群（control groups）的简写，是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。

### 1.4.2. NAMESPACE

   命名空间是Linux内核的一项功能，它对内核资源进行分区。这个隔离的分区中包括了：UTS（主机名和域名）、IPC（信号量、消息队列和共享内存）、PID（进程编号）、Network（网络设备、网络栈、端口等）、Mount（挂载点）、User（用户和用户组）。

以下是linux内核各个版本对namespace的支持

 

| Namespace | 系统调用参数        | 隔离内容          | Linux内核版本 |
| --------- | ------------- | ------------- | --------- |
| UTS       | CLONE_NEWUTS  | 主机名与域名        | 2.6.19    |
| IPC       | CLONE_NEWIPC  | 信号量、消息队列和共享内存 | 2.6.19    |
| PID       | CLONE_NEWPID  | 进程编号          | 2.6.24    |
| Network   | CLONE_NEWNET  | 网络设备、网络栈、端口等等 | 2.6.29    |
| Mount     | CLONE_NEWNS   | 挂载点（文件系统）     | 2.6.19    |
| User      | CLONE_NEWUSER | 用户和用户组        | 3.8       |

 

### 1.4.3. UnionFS

 

是一种为Linux，FreeBSD和NetBSD操作系统设计的把其他文件系统联合到一个联合挂载点的文件系统服务，使用的是写时复刻的功能，也就是底层构建，联合挂载

 

## 1.5. 基本概念

Docker主要包括三个基本概念

### 1.5.1. 镜像（Image）

对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。

### 1.5.2. 容器 (Container)

镜像和容器的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。

 

### 1.5.3. 仓库（Repository）

​      仓库是储藏镜像的场所，默认安装的docker中是没有镜像文件的。需手动拉去镜像文件。官方默认的站点是docker-hub。

 

###  

 

###  

 

 

 

 

 

 

 

 

 

 

 

 

 

 